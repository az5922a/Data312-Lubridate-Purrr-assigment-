---
title: "Lecture 5 Scripts and Practice"
format: 
  html:
    self-contained: true
editor: visual
---

## Forward geocoding

You can use the tidygeocoder package in R.

The code below is an example of forward geocoding (addresses ⮕ coordinates). By default, geocode() uses Nominatim (a geocoding software package) to perform the task.

```{r}
# run via Console if not installed before: 
# install.packages("tidygeocoder")
library(tidygeocoder)
addresses_df <- data.frame(address = c("60 College St, New Haven, CT"))                              
geocode(addresses_df, address = address)
```

## Forward geocoding

It can process multiple addresses:

```{r}
# run if not installed before: install.packages("tidygeocoder")
library(tidygeocoder)
addresses_df_v2 <- data.frame(address = c("1600 Pennsylvania Avenue, Washington, DC",
                                       "1313 Disneyland Dr, Anaheim, CA"))                              
geocode(addresses_df_v2, address = address)

```

## Forward geocoding

If you are interested in determining the geographies (e.g., county, tract information), we need to use the census method which leverages the Census API.

```{r}
# run if not installed before: install.packages("tidygeocoder")
library(tidygeocoder)
addresses_df_v3 <- data.frame(address = c("26 Plympton St, Cambridge, MA"))                              
results_df <- geocode(addresses_df_v3, address = address, method = "census", 
        full_results = TRUE, api_options = list(census_return_type = 'geographies'))

# Script you need to run to see county information
results_df$geographies.Counties

# Script you need to run to see county information
results_df$`geographies.Census Tracts`
```

## Reverse geocoding

```{r}
reverse_geo(lat = "41.30374", long = "-72.93216")
```

## Practice 1

Using the tidygeocoder package, determine the 5-digit county FIPS or GEOID code for the following address: 9641 W Sunset Blvd, Beverly Hills, CA

```{r}
addresses_df_v3 <- data.frame(address = c("9641 W Sunset Blvd, Beverly Hills, CA"))                              
results_df <- geocode(addresses_df_v3, address = address, method = "census", 
        full_results = TRUE, api_options = list(census_return_type = 'geographies'))

results_df$geographies.Counties
```

## censusapi package: pulling data into R

Suppose we are interesting in county-level population data. According to the ACS 2022 table shell, the variable we need to use is: B01001_001E.

We can use the censusapi package to get census data directly into R.

```{r}
install.packages("censusapi")

# Load the package
library(censusapi)

# Ensure your API key is set
Sys.setenv(CENSUS_KEY = "b74763593fa28b0b627eaa637bbda9f7efb61ef9")

# Call getCensus() using the package namespace to avoid conflicts
data1 <- censusapi::getCensus(
  name = "acs/acs5", 
  vintage = 2019,
  vars = c("B28002_001E", "B28002_002E"),
  region = "county:*"
)

# View the first few rows
head(data1)

```

## Examples of Other Important censusapi calls

An example of asking for multiple variables:

```{r}
Sys.setenv(CENSUS_KEY = "b74763593fa28b0b627eaa637bbda9f7efb61ef9")

# Call getCensus() using the package namespace to avoid conflicts
data1 <- censusapi::getCensus(
  name = "acs/acs5", 
  vintage = 2019,
  vars = c("B28002_001E", "B28002_002E"),
  region = "county:*"
)

# View the first few rows
head(data1)
```

An example of asking for Connecticut-only county-level data (Note: CT's FIPS code is 09).

```{r}
data2 <- censusapi::getCensus(
  name = "acs/acs5", 
  vintage = 2019,
  vars = c("B28002_001E", "B28002_002E"), 
  region = "county:*", 
  regionin = "state:09")

head(data2)
```

An example of asking for Missouri-only tract-level data (Note: MO's FIPS code is 29).

```{r}
data3 <- censusapi::getCensus(name = "acs/acs5", vintage = 2019, 
                   vars = c("B28002_001E", "B28002_002E"), 
                   region = "tract:*", regionin = "state:29")
head(data3)
```

## Creating SVI Map for MO

Step 1: Retrieve shapefile needed.

```{r}
library(tigris) 
mo_shape_file <- tracts(state = "MO", year = 2019)
# not required but nice to visualize data
head(mo_shape_file)
```

Step 2: Load MO SVI data into R.

```{r}
library(tidyverse) 
mo_svi_data <- read_csv("https://raw.githubusercontent.com/jmtfeliciano/teachingdata/refs/heads/main/MissouriSVI2019.csv") |>
  mutate(GEOID = as.character(FIPS)) # rename FIPS into GEOID

```

Step 3: Merge SVI data into shapefile.

```{r}
mo_shape_file_v2 <- left_join(mo_shape_file, mo_svi_data)
```

Step 4: Plot map (Note: RPL_THEMES is the SVI variable).

```{r}
ggplot(data = mo_shape_file_v2, aes(fill= RPL_THEMES)) + geom_sf()
```

```{r}
ggplot(data = mo_shape_file_v2, 
       aes(fill = RPL_THEMES)) +
  geom_sf()

```

## Generating Map

```{r}
ggplot(data = mo_shape_file_v2, 
       aes(fill = RPL_THEMES)) +
  geom_sf()
```

## Further Customizations

```{r}
# Added theme_void() 
# to remove grid and grey background
ggplot(data = mo_shape_file_v2, 
       aes(fill = RPL_THEMES)) +
  geom_sf() +
  theme_void()

```

## Further Customizations Part 2

```{r}
# Further customizes labels and color gradient
ggplot(data = mo_shape_file_v2, 
       aes(fill = RPL_THEMES)) +
  geom_sf() +
  theme_void() +
  scale_fill_gradient(low="#1fa187", 
                      high="#440154") +
  labs(fill='MO-Specific SVI')
```

## Practice 2

Our joint-task: Create a VA county-level map using counties() using CDC data for 2023-03-03. Create visualization for **covid_cases_per_100k** variable specifically.

**Step 1:** As a class, let us create a va_shape_file R object using counties() for Virginia only and for year 2023.

```{r}
# Our code here below 

# Load required package
library(tigris)

# Retrieve county-level shapefile for Virginia (VA) for 2023
va_shape_file <- counties(state = "VA", year = 2023)

# Inspect the first few rows to confirm
glimpse(va_shape_file)

```

```{r}
library(tigris)

va_shape_file <- counties(states = "VA", year=2023)

head(va_shape_file)
```

**Step 2:** Eventually create a virginia 2023 data frame (call it virginia_cases_df) from covid_cases_df that we will eventually left_join into the shapefile

```{r}
# covid_cases_df is CDC data for the entire country
covid_cases_df <- read_csv("https://raw.githubusercontent.com/jmtfeliciano/teachingdata/refs/heads/main/cdc_covid_county_data_20230303.csv") 
head(covid_cases_df)

# Our code here below
virginia_cases_df <- covid_cases_df |>
  filter(state == "VA") |>  
  select(county_fips, covid_cases_per_100k)  

head(virginia_cases_df)

```

```{r}
# Our code here below

# Our code here below
virginia_cases_df <- covid_cases_df |>
  filter(state == "Virginia") |>  
  select(county_fips, covid_cases_per_100k)  

head(virginia_cases_df)
```

**Step 3: left join data we want to render into a map into the shapefile to create desired shapefile**

```{r}
# Our code here below

va_shape_file <- va_shape_file |> 
  left_join(virginia_cases_df, by = c("GEOID" = "county_fips"))

head(va_shape_file)

```

**Step 4: Render the VA map!**

Use desired shapefile to render map

```{r}
# Our code here below


ggplot(data = va_shape_file) +
  geom_sf(aes(fill = covid_cases_per_100k)) +
  scale_fill_viridis_c(option = "plasma", na.value = "grey50") + # Color scale
  labs(title = "COVID-19 Cases per 100k in Virginia Counties",
       fill = "Cases per 100k") +
  theme_void()
```

## tidycensus package and census data

tidycensus is an R package that allows users to interface with a select number of the US Census Bureau’s data APIs and return data frames.

If you want to map ACS-related data, the tidycensus package is the most convenient way to go. One of the advantages of using tidycensus is it has the option to return not just the requested variable(s) but also the corresponding shapefile needed. If your goal is to visualize Census data via a map, tidycensus is the package to use.

Before going further, load the tidycensus package:

```{r}
# run install.packages("tidycensus") if not installed
library(tidycensus)
```

## tidycensus package and census data.

The script below uses `load_variables()` to list the available variables within the 2023 ACS5 data--this is a table shell but loaded into R as a data frame. Remember, when someone refers to '2023 ACS 5 data', the estimates actually use data for 2019-2023).

```{r}
variable_list_2022 <- load_variables(2022, "acs5", cache = TRUE)
nrow(variable_list_2022)
```

```{r}
head(variable_list_2022)

```

## tidycensus package and census data

Advanced recipe: using basic text mining skills in R to find tables related to medicare.

```{r}
variable_list_2022 |>
  filter(str_detect(concept, regex("medicare", ignore_case = TRUE))) |>
  relocate(concept) 
```

## tidycensus package

Task: Suppose we want to map the median % of household income spent on rent for each state using variable B25071_001.

The key part here is: Make sure geometry = TRUE as the default is FALSE. By setting geometry as TRUE, you are instructing get_acs() to return the final data as an SF object (shapefile) that is ready for map rendering via ggplot2. shift_geo = TRUE is also important as it will compress the distance between the contiguous United States with Alaska, Hawaii, and Puerto Rico.

NOTE: when we looked at the table shells, we added 'E' at the end of the variable name when using the censusapi package. For tidycensus, it is not required.

```{r}
library(tidycensus)
library(sf)  # Ensure sf is loaded for CRS fix

census_api_key("b74763593fa28b0b627eaa637bbda9f7efb61ef9")

shapefile_with_data <- get_acs(
  geography = "state",
  variables = "B25071_001",
  year = 2019,
  survey = "acs5",
  geometry = TRUE) 

# Apply `shift_geometry()` instead of `shift_geo = TRUE`
shapefile_with_data <- shift_geometry(shapefile_with_data)

# Update CRS to latest version
shapefile_with_data <- st_transform(shapefile_with_data, crs = st_crs(4326))  
```

## Rendering the map

```{r}
ggplot(data = shapefile_with_data,
       aes(fill = estimate)) + 
  geom_sf() +
  theme_void() +
  labs(fill='Median Gross Rent as a % of Household Income') +
  scale_fill_gradient(low="#1fa187", 
                      high="#440154") +
  theme(legend.position="bottom")

```

## Rendering the map: Example 2 (Full Template)

```{r}
library(tidycensus)
library(tidyverse)
census_api_key("b74763593fa28b0b627eaa637bbda9f7efb61ef9")
ct_shapefile_with_data <- get_acs(
  geography = "county",
  state = "CT",
  variables = "B25071_001",
  year = 2019,
  survey = "acs5",
  geometry = TRUE )
  # shift_geo is not needed if you're not mapping entire US) 
ggplot(data = ct_shapefile_with_data,
       aes(fill = estimate)) + 
  geom_sf() +
  theme_void() +
  labs(fill='Median Gross Rent as a % of Household Income') +
  scale_fill_gradient(low="white", 
                      high="black")
```

## Other functions from tidycensus

`get_estimates()` can give you detailed information about population characteristics. In your own time, try changing the value of `product` to the following: "components", "population", or characteristics".

```{r}
get_estimates(geography = "state", product = "components", vintage = 2023)
```

## Other functions from tidycensus

`get_flows()` provides detailed migration flow data (if available).

```{r}
get_flows(
  geography = "county",
  state = "AZ",
  county = "Maricopa",
  year = 2019)
```

## Post-class exercise ideas

Use tidycensus to create other maps.

Use the tigris package with outside data you want to create a map for, and create a map of your own choosing!
